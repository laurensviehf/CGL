\documentclass[10pt,a4paper,ngerman]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage[onehalfspacing]{setspace}
\usepackage{array}
\usepackage{upgreek}
\usepackage{float}
\usepackage{csquotes}
\usepackage{chemformula}
\usepackage{chemgreek}
\usepackage{chemmacros}
\chemsetup{modules=all}
\usepackage{tikz}
\usepackage{siunitx}
\sisetup{locale = DE,per-mode = symbol}
\usepackage{esvect}
\usepackage{geometry}
\usepackage{pdfpages}
\usepackage[font=small]{caption}
%\usepackage[version=4]{mhchem}
\usepackage[backend=biber, style=chem-angew]{biblatex}
\addbibresource{Sheet07.bib}
\usepackage{tabularx, booktabs, multirow}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{scrlayer-scrpage}%Header für die KOMA-script -Klasse
%\usepackage{hyperref}
\usepackage{pgfplots}
\usepackage{textgreek}
\usepackage{listings}

\definecolor{codegray}{rgb}{0.1, 0.1, 0.1} % Dunkler Hintergrund
\definecolor{codecomment}{rgb}{0.4, 0.6, 0.4} % Grüner für Kommentare
\definecolor{codekeyword}{rgb}{0.7, 0.5, 1.0} % Lila für Schlüsselwörter
\definecolor{codestring}{rgb}{0.9, 0.6, 0.4} % Orange für Strings
\definecolor{codetext}{rgb}{0.9, 0.9, 0.9} % Heller Text

\lstset{
  language=Python,
  backgroundcolor=\color{codegray},
  basicstyle=\small\ttfamily\color{codetext},
  keywordstyle=\color{codekeyword}\bfseries,
  commentstyle=\color{codecomment}\itshape,
  stringstyle=\color{codestring},
  frame=single,
  framesep=2mm,
  breaklines=true,
  showstringspaces=false
}

\newcommand{\tildenu}{{\fontencoding{LGR}\selectfont\accperispomeni\textnu}}
\captionsetup{format=plain}
\chemsetup[phases]{pos=sub}
\chemsetup[redox]{pos=top}
\chemsetup[redox]{align=center}
%\chemsetup[redox]{explicit-sign=true}
%\chemsetup[redox]{roman=false}
\newcommand{\celsius}{^{\circ}\mathrm{C}}
\parindent0pt
\sloppy
\DeclareChemPhase{\s}{s}
\DeclareChemPhase{\l}{l}
\DeclareChemPhase{\g}{g}
\renewcaptionname{ngerman}{\figurename}{Abb.}
\renewcaptionname{ngerman}{\tablename}{Tab.}
\geometry{bottom=100pt} \geometry{top=80pt}
\newcommand{\m}{\mathrm{m}}
\newcommand{\K}{\mathrm{K}}
\newcommand{\J}{\mathrm{J}}
\newcommand{\gr}{\mathrm{g}}
\newcommand{\kg}{\mathrm{kg}}
\newcommand{\mol}{\mathrm{mol}}
\newcommand{\Pa}{\mathrm{Pa}}
\newcommand{\ad}{\mathrm{ad}}
\newcommand{\de}{\mathrm{de}}
\newcommand{\gmol}{\mathrm{\frac{g}{mol}}}
\newcommand{\JKmol}{\mathrm{\frac{J}{K \cdot mol}}}
\newcommand{\kgmss}{\mathrm{\frac{kg}{m \cdot s^2}}}
\newcommand{\loge}{\mathrm{ln}}

\begin{document}
\begin{titlepage}
	\vspace*{2.5cm}
	\begin{center}
		\begin{LARGE}
			\textbf{CGL}\\
			\textbf{Blatt 7}\\
		\end{LARGE}
		\vspace{1cm}
		\textbf{Universität Stuttgart}\\
		\vspace*{1,5cm}
		\begin{tabular}{lp{7,5cm}l}
			Author 1:     &Laurens Viehoff\\
            Author 2:     &Felix Roth\\   
		\end{tabular}
	\end{center}

    \begin{center}
        \textbf{\Large Abstract}
    \end{center}
    
\end{titlepage}
\thispagestyle{empty}
\renewcommand{\thepage}{\arabic{page}}
\newpage
\tableofcontents
\setcounter{page}{1}
\renewcommand{\thepage}{\arabic{page}}
\newpage

\section{Aufgabe 1}
Hier der Nachweis für die Nature einbindung von Quelle \cite{biamonte_quantum_2017}.
\begin{figure}[H]
	\centering
    \includegraphics[width=0.9\linewidth]{Zotero_Nachweis_quantum.png}
    \caption{Hier des Quantum machine learning paper.}
    \label{fig:Quantummachinelearning}
\end{figure}
Hier dann noch der Nachweis der eigenen Erstellung einer Quelle vom Buch \cite{demtroder_experimentalphysik_2003}.
\begin{figure}[H]
	\centering
    \includegraphics[width=0.9\linewidth]{Zotero_Nachweis_Demtröder.png}
    \caption{Hier das Demtröder Buch.}
    \label{fig:Raman_Chloroform}
\end{figure}


\section{Aufgabe 2}
\begin{lstlisting}
import random
import math
import matplotlib.pyplot as plt

def generate_random_point_in_square(length):
    """
    Generate a random point in a square of a given side length centered around the origin with the sides aligned with x- and y-axis.
    """
    return tuple([length*random.uniform(-0.5, 0.5), length*random.uniform(-0.5, 0.5)])

def distance(p1, p2):
    """
    Measures the Euclidean distance between the points p1 and p2 in 2D.
    """

    return math.sqrt((p2[0]-p1[0])**2+(p2[1]-p1[1])**2)


def point_in_circle(p, center=[0,0], radius=None):
    """
    Checks if the provided point p lies in a circle of a given radius around the provided center.
    """
    length = distance(center, p)

    if length <= radius:

        print("liegt im Bereich")
        return True
    else:
        print("leigt nicht im Bereich")
        return False
i= 1
full_list_of_points = []

while i < 1000:

    full_list_of_points.append(generate_random_point_in_square(2.0))
    i = i+1

filtered_list_of_points = []

while i <= len(full_list_of_points):

    if point_in_circle(full_list_of_points[i]) == True:
        filtered_list_of_points.append(full_list_of_points[i])
        i = i+1
    else:
        i =i+1

print(len(filtered_list_of_points)/(len(full_list_of_points)-len(filtered_list_of_points)))
# TODO: Generate separate lists of the x- and y-values of full_list_of_points and filtered_list_of_points
x_values_full = 
y_values_full = 

x_values_filtered =
y_values_filtered =

plt.scatter(x_values_full, y_values_full)
plt.scatter(x_values_filtered, y_values_filtered)
plt.show()
\end{lstlisting}

\section{Aufgabe 3}
\begin{lstlisting}
    import matplotlib.pyplot as plt

dateiname = "sheet07\messdaten.txt"
x_werte = []
y_werte = []

# 1. Datei öffnen und Schleife über Zeilen
with open(dateiname, 'r') as datei:
    print(f"Verarbeite Daten aus '{dateiname}'...")
    
    for zeilennummer, zeile in enumerate(datei, 1):
        
        # 2. .strip() verwenden
        bereinigte_zeile = zeile.strip()
        
        # 3. Filtern von leeren Zeilen und Kommentaren
        if not bereinigte_zeile or bereinigte_zeile.startswith('#'):
            # Ignoriere auch Zeilen, die mit '#' (Kommentar) beginnen
            continue
        
        # 4. Sonst Zeile ausgeben und Werte extrahieren
        print(f"Verarbeite: '{bereinigte_zeile}'")
        
        #Teile die bereinigte_zeile in Einzelteile auf
        teile = bereinigte_zeile.split()

        print(teile)
        
        if len(teile) == 2:
            # Wandel die Teile in Gleitkommazahlen um
            x = float(teile[0])
            y = float(teile[1])
            
            # Speicher die Werte in den Listen x_werte und y_werte
        x_werte.append(x)
        y_werte.append(y)


# 5. Am Ende alle Tupel x-y plotten
if x_werte:
    print(f"Erfolgreich {len(x_werte)} Datenpunkte gesammelt. Erstelle Plot.")
    
    plt.figure()
    # Verwende Sie plt.scatter() um x_werte gegen y_werte zu plotten
    plt.scatter(x_werte, y_werte, label = "yeet")
    
    plt.title('Messdaten aus Datei')
    plt.xlabel('X-Koordinate')
    plt.ylabel('Y-Koordinate')
    plt.grid(True)
    plt.savefig('messdaten_plot.pdf')
    plt.show()
else:
print("keine gültigen Daten zum Plotten gefunden.")
\end{lstlisting}
\printbibliography

\end{document}